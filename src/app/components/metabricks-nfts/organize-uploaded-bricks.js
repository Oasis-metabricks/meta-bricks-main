const fs = require('fs-extra');
const path = require('path');

// Create organized folder structure for uploaded MetaBricks
async function organizeUploadedBricks() {
    const baseDir = path.join(__dirname, 'uploaded-metabricks');
    
    try {
        console.log('üìÅ Creating organized folder structure for MetaBricks...\n');
        
        // Create main directory
        await fs.ensureDir(baseDir);
        
        // Create subdirectories by brick type
        const directories = {
            regular: path.join(baseDir, '01-regular-bricks'),
            industrial: path.join(baseDir, '02-industrial-bricks'),
            legendary: path.join(baseDir, '03-legendary-bricks'),
            metadata: path.join(baseDir, 'metadata'),
            images: path.join(baseDir, 'images'),
            results: path.join(baseDir, 'upload-results')
        };
        
        // Store directory paths for README creation
        const dirPaths = {
            '01-regular-bricks': directories.regular,
            '02-industrial-bricks': directories.industrial,
            '03-legendary-bricks': directories.legendary
        };
        
        // Create all directories
        for (const [name, dirPath] of Object.entries(directories)) {
            await fs.ensureDir(dirPath);
            console.log(`‚úÖ Created: ${name} directory`);
        }
        
        // Create README files for each directory
        await createReadmeFiles(baseDir, dirPaths);
        
        // Create summary files
        await createSummaryFiles(baseDir);
        
        console.log('\nüéØ Folder Structure Created:');
        console.log('üìÅ uploaded-metabricks/');
        console.log('   ‚îú‚îÄ‚îÄ 01-regular-bricks/     (Regular brick metadata)');
        console.log('   ‚îú‚îÄ‚îÄ 02-industrial-bricks/  (Industrial brick metadata)');
        console.log('   ‚îú‚îÄ‚îÄ 03-legendary-bricks/   (Legendary brick metadata)');
        console.log('   ‚îú‚îÄ‚îÄ metadata/              (All JSON files)');
        console.log('   ‚îú‚îÄ‚îÄ images/                (Brick image references)');
        console.log('   ‚îú‚îÄ‚îÄ upload-results/        (Upload logs & results)');
        console.log('   ‚îú‚îÄ‚îÄ README.md              (Main documentation)');
        console.log('   ‚îî‚îÄ‚îÄ SUMMARY.md             (Quick reference)');
        
        console.log('\nüöÄ Ready to organize your uploaded MetaBricks!');
        
    } catch (error) {
        console.error('‚ùå Error creating folder structure:', error);
    }
}

// Create README files for each directory
async function createReadmeFiles(baseDir, directories) {
    // Main README
    const mainReadme = `# üß± MetaBricks Upload Organization

## üìÅ Directory Structure

### **01-regular-bricks/**
Contains all regular brick metadata files (JSON) that have been uploaded to Pinata.

### **02-industrial-bricks/**
Contains all industrial brick metadata files (JSON) that have been uploaded to Pinata.

### **03-legendary-bricks/**
Contains all legendary brick metadata files (JSON) that have been uploaded to Pinata.

### **metadata/**
Contains all 432 MetaBrick JSON files in one location.

### **images/**
Contains references to the brick PNG images on Pinata.

### **upload-results/**
Contains upload logs, IPFS hashes, and results from the Pinata upload process.

## üéØ How to Use

1. **For NFT Minting**: Use the IPFS hashes from upload-results/
2. **For Development**: Access individual brick types from their respective folders
3. **For Reference**: Check metadata/ for all files in one place

## üîó Pinata Links

- **Regular Bricks**: [View on Pinata](https://app.pinata.cloud/)
- **Industrial Bricks**: [View on Pinata](https://app.pinata.cloud/)
- **Legendary Bricks**: [View on Pinata](https://app.pinata.cloud/)

## üìä Total Count

- **Total MetaBricks**: 432
- **Regular Bricks**: ~260 (60%)
- **Industrial Bricks**: ~130 (30%)
- **Legendary Bricks**: ~43 (10%)

---
*Generated by MetaBricks Upload System*
`;

    await fs.writeFile(path.join(baseDir, 'README.md'), mainReadme);
    
    // Individual README files for each brick type
    const brickTypeReadmes = {
        '01-regular-bricks': {
            title: 'Regular Bricks',
            description: 'Standard MetaBricks with common perks and benefits.',
            rarity: 'Common (60% of total)',
            perks: '1 mystery perk + MetaBrick Keychain'
        },
        '02-industrial-bricks': {
            title: 'Industrial Bricks',
            description: 'Enhanced MetaBricks with improved perks and benefits.',
            rarity: 'Uncommon (30% of total)',
            perks: '2 mystery perks + MetaBrick Keychain'
        },
        '03-legendary-bricks': {
            title: 'Legendary Bricks',
            description: 'Rare MetaBricks with premium perks and maximum benefits.',
            rarity: 'Rare (10% of total)',
            perks: '2 mystery perks + MetaBrick Keychain'
        }
    };
    
    for (const [dirName, info] of Object.entries(brickTypeReadmes)) {
        const readmeContent = `# ${info.title}

## üìã Description
${info.description}

## üé≠ Rarity
${info.rarity}

## üéÅ Perks
${info.perks}

## üìÅ Contents
This directory contains all ${info.title.toLowerCase()} metadata files that have been uploaded to Pinata.

## üîó Usage
Use these files for:
- NFT minting
- Metadata verification
- Perk reveal system
- Community engagement

---
*Part of the MetaBricks Collection*`;
        
        await fs.writeFile(path.join(directories[dirName.replace(/\d+-/, '')], 'README.md'), readmeContent);
    }
}

// Create summary files
async function createSummaryFiles(baseDir) {
    // Summary file
    const summary = `# üß± MetaBricks Quick Summary

## üìä Collection Overview
- **Total Bricks**: 432
- **Brick Types**: 3 (Regular, Industrial, Legendary)
- **Perk System**: Threshold-based reveals
- **Storage**: Pinata IPFS

## üé≠ Perk Reveal Thresholds
- **10% (43 bricks)**: FREE hApp, FREE OLAND, FREE Statue
- **25% (108 bricks)**: Bronze API, Silver API
- **50% (216 bricks)**: Gold API, Free OAPP, Billboard, Landmark
- **75% (324 bricks)**: Token Integration, Custom AR, Custom Building
- **100% (432 bricks)**: OASIS Integration, Early Access

## üöÄ Next Steps
1. ‚úÖ MetaBricks uploaded to Pinata
2. ‚úÖ Metadata organized by type
3. üîÑ Ready for NFT minting
4. üîÑ Ready for MetaBricks wall launch

## üìÅ Key Files
- **upload-results/**: IPFS hashes for minting
- **metadata/**: All 432 JSON files
- **images/**: Brick image references

---
*Generated: ${new Date().toISOString()}*`;

    await fs.writeFile(path.join(baseDir, 'SUMMARY.md'), summary);
    
    // Brick count file
    const brickCounts = {
        regular: 0,
        industrial: 0,
        legendary: 0,
        total: 432
    };
    
    await fs.writeFile(path.join(baseDir, 'brick-counts.json'), JSON.stringify(brickCounts, null, 2));
}

// Function to organize uploaded files into the structure
async function organizeFiles() {
    const metadataDir = path.join(__dirname, 'assets', 'metadata');
    const organizedDir = path.join(__dirname, 'uploaded-metabricks');
    
    try {
        console.log('üìÅ Organizing MetaBrick files into structured folders...\n');
        
        if (!await fs.pathExists(metadataDir)) {
            console.log('‚ùå Metadata directory not found');
            return;
        }
        
        // Get all JSON files
        const files = await fs.readdir(metadataDir);
        const jsonFiles = files.filter(file => file.endsWith('.json'));
        
        let organizedCount = 0;
        
        for (const file of jsonFiles) {
            const filePath = path.join(metadataDir, file);
            const content = await fs.readFile(filePath, 'utf8');
            const metadata = JSON.parse(content);
            
            // Determine brick type
            const brickType = metadata.hiddenMetadata?.type || 'regular';
            
            // Copy to appropriate directory
            const targetDir = path.join(organizedDir, `${brickType}-bricks`);
            const targetFile = path.join(targetDir, file);
            
            await fs.copy(filePath, targetFile);
            organizedCount++;
        }
        
        // Copy all files to metadata directory
        const metadataTargetDir = path.join(organizedDir, 'metadata');
        for (const file of jsonFiles) {
            const sourcePath = path.join(metadataDir, file);
            const targetPath = path.join(metadataTargetDir, file);
            await fs.copy(sourcePath, targetPath);
        }
        
        console.log(`‚úÖ Organized ${organizedCount} MetaBrick files into structured folders!`);
        console.log(`üìÅ Check the 'uploaded-metabricks' directory for the organized structure.`);
        
    } catch (error) {
        console.error('‚ùå Error organizing files:', error);
    }
}

// Export functions
module.exports = {
    organizeUploadedBricks,
    organizeFiles
};

// Run if executed directly
if (require.main === module) {
    const args = process.argv.slice(2);
    
    if (args.includes('--organize-files')) {
        organizeFiles();
    } else {
        organizeUploadedBricks();
    }
}
